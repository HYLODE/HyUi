# src/mock/mock.py
"""
Generates sqlite database with a table holding modelled as per
api.models.Results and then loads the data from the local HDF file
"""

import sys
import pandas as pd
import sqlalchemy as sa
from pathlib import Path
from sqlmodel import Session, SQLModel, create_engine
from sqlmodel.pool import StaticPool

from config.settings import settings  # type: ignore
from utils import get_model_from_route  # type: ignore

# you can use this function in testing but swap in an in memory version
SYNTH_SQLITE_FILE = Path(__file__).parent / "mock.db"
SYNTH_SQLITE_URL = f"sqlite:///{SYNTH_SQLITE_FILE}"
SYNTH_SQLITE_MEM = "sqlite://"
ECHO = False


def path_to_hdf_file(route: str):
    """Prep path to file based on route"""
    return Path(__file__).parents[1] / "api" / route / "mock.h5"


def make_engine(path=SYNTH_SQLITE_URL, **kwargs):
    engine = create_engine(path, **kwargs)
    return engine


def make_mock_df(f: Path) -> pd.DataFrame:
    """
    Makes a dataframe from the HDF file generated by the code in ./synth
    """
    try:
        assert f.is_file()
    except AssertionError as e:
        print(e)
        print(f"!!! Synthetic data not found at {f}")
        print("!!! Follow the instructions in ./synth/readme.md to generate")
        print("!!! Then check that you've manually copied the HDF file")
        print("!!! from ./synth/portal/ to ./src/mock/")
        raise AssertionError(e)

    df = pd.read_hdf(f)
    return df  # type: ignore


def create_mock_table(engine, model: SQLModel, drop=False):
    # metadata is defined when you run the import statement above
    table = model.__table__  # type: ignore
    if drop:
        SQLModel.metadata.drop_all(engine, tables=[table])
    # force it fail if drop not issued
    try:
        SQLModel.metadata.create_all(engine, tables=[table], checkfirst=False)
    except sa.exc.OperationalError as e:
        print(e)
        print("==============================================================")
        print("??? Try using drop=True to force the table to be deleted first")


def insert_into_mock_table(engine, df: pd.DataFrame, model: SQLModel):
    rows = df.to_dict(orient="records")
    with Session(engine) as session:
        for row in rows:
            session.add(model(**row))  # type: ignore
        session.commit()
    return 0


def make_mock_db_in_memory(route: str):
    """
    Use SQLModel to create a temporary db in memory for testing etc
    Convenience function that wraps others
    Uses route to define the HDF data file and the SQL model
    """
    engine = make_engine(
        path=SYNTH_SQLITE_MEM,
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
    model = get_model_from_route(route, "Table")
    hdf_file = path_to_hdf_file(route)
    df = make_mock_df(hdf_file)
    create_mock_table(engine, model, drop=True)
    insert_into_mock_table(engine, df, model)
    return engine


if __name__ == "__main__":
    engine = make_engine(echo=True)
    for route in settings.ROUTES:
        try:
            model = get_model_from_route(route, "Table")
            hdf_file = path_to_hdf_file(route)
            df = make_mock_df(hdf_file)
            create_mock_table(engine, model, drop=True)
            insert_into_mock_table(engine, df, model)
        except Exception as e:
            print(e)
            sys.exit(1)
